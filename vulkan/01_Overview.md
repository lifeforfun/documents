#### Vulkan的起点
   与其他的图形API一样，Vulkan被设计为[GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit)跨平台抽象的。
大部分这些API的问题是由于设计它们时那个年代图像硬件被限制为固定的一些可配置的功能。程序员需要以标准格式提供顶点数据并且受GPU亮度、着色产业限制。

   随着显卡工艺日趋成熟，开始提供越来越多的可编程功能。这些新的功能需要以某种方式集成进已有的API中。这就导致抽象程度不高并且需要很多臆测工作去覆盖程序员对现代图像工艺的需求。
这就是为什么为了提升游戏性能而发布如此多的驱动了,有时甚至是以重要补丁的方式发布。由于这些驱动的复杂性，应用开发者需要处理供应商的不一致行为，比如接受不同的[着色器](https://en.wikipedia.org/wiki/Shader)语法
除了这些新特性，过去十年间也汇集了一批搭载强大图形处理器的移动设备。这些移动端GPU基于能耗和空间的需求采用的工艺也不尽相同。
比如其中一种技术叫[排列式成像](https://en.wikipedia.org/wiki/Tiled_rendering)。受益于性能的提升，这项功能可以给予开发人员更多的控制权。
另一个在这些API产生的年代就存在的问题是对多线程的支持，这最终成为了CPU的瓶颈。

   通过为现代图形工艺设计重新设计全新的API，Vulkan能够解决以上这些问题。
它能让开发人员更清楚地选择符合他们预期的API来减轻驱动负担，并且允许通过多线程并行创建和提交命令。
通过切换到标准字节码格式和单一的编译器，减少了编译着色器的不一致性。
最终，通过将图形和计算功能统一为单一的API，实现了现代图形卡处理能力的通用目标。
#### 画一个三角形需要什么?

##### 第1步：实例和物理设备的选择
##### 第2步：逻辑设备和队列簇
##### 第3步：窗口表层和交换链
##### 第4步：图像视图和帧缓冲
##### 第5步：渲染层
##### 第6步：图像管道
##### 第7步：命令池和命令缓存区
##### 第8步：主循环