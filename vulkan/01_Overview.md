#### Vulkan的起点
   与其他的图形API一样，Vulkan被设计为[GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit)跨平台抽象的。
大部分这些API的问题是由于设计它们时那个年代图像硬件被限制为指定的一些可配置的功能。程序员需要以标准格式提供顶点数据并且受GPU亮度、着色产业限制。

   随着显卡工艺日趋成熟，开始提供越来越多的可编程功能。这些新的功能需要以某种方式集成进已有的API中。这就导致抽象程度不高并且需要很多臆测工作去覆盖程序员对现代图像工艺的需求。
这就是为什么为了提升游戏性能而发布如此多的驱动了,有时甚至是以重要补丁的方式发布。由于这些驱动的复杂性，应用开发者需要处理供应商的不一致行为，比如接受不同的[着色器](https://en.wikipedia.org/wiki/Shader)语法
除了这些新特性，过去十年间也汇集了一批搭载强大图形处理器的移动设备。这些移动端GPU基于能耗和空间的需求采用的工艺也不尽相同。
比如其中一种技术叫[排列式成像](https://en.wikipedia.org/wiki/Tiled_rendering)。这项功能可以给予开发人员更多的控制权而从性能提升中受益。
另一个在这些API产生的年代就存在的问题是对多线程的支持，这最终成为了CPU的瓶颈。

   通过为现代图形工艺设计重新设计全新的API，Vulkan能够解决以上这些问题。
它能让开发人员更清楚地选择符合他们预期的API来减轻驱动负担，并且允许通过多线程并行创建和提交命令。
通过切换到标准字节码格式和单一的编译器，减少了编译着色器的不一致性。
最终，通过将图形和计算功能统一为单一的API，实现了现代图形卡处理能力的通用目标。

#### 画一个三角形需要什么?
   接下来我们看看一个良好的Vulkan程序渲染一个三角形需要哪些步骤。这里引进的所有概念将会下接下来的章节里详细讲解。这里只是给你一个关于所有这些独立组件的大致的印象。

##### 第1步：实例和物理设备的选择
   一个Vulkan应用通过`VkInstance`设置Vulkan API开始。一个实例创建时携带了描述应用和任何你用到的API扩展信息。创建实例后，你可以查询Vulkan支持的硬件，选择使用一个或多个`VkPhysicalDevice`来进行操作。
你可以查找类似`VRAM`大小这样的属性或设备能力来确定选择哪些设备。例如你会更倾向于使用专业的图形卡。

##### 第2步：逻辑设备和队列簇
   在选择使用合适的硬件之后你需要创建一个`VkDevice`(逻辑设备)。它可以更详细地描述你要使用的类似于视窗渲染和64位浮点这些`VkPhysicalDeviceFeatures`(物理设备属性)。
同样你还需要指定使用哪种队列簇。用Vulkan执行的大部分操作比如画图命令和内存操作都是通过提交给`VkQueue`异步执行的。这些队列是通过队列簇分配。每种队列簇支持他的队列的一些指定操作集。
例如，针对图形、计算、内存传输操作可能分别有对应的队列簇来处理。不同队列簇的可用性可以作为选择物理设备的评判条件。可能一个Vulkan支持的设备不提供任何图形方面的功能。但现今所有Vulkan支持的图形卡通常都支持所有我们感兴趣的队列操作。

##### 第3步：窗口表层和交换链
   除非你对幕后渲染感兴趣，否则你需要创建一个窗口去显示渲染的图像。窗口可以通过类似[GLFW](http://www.glfw.org/)和[SDL](https://www.libsdl.org/)这些平台原生API或库创建。在这个指南里我们使用GLFW,下个章节会介绍更多这方面的内容。
   
我们还需要两个组件来向窗口里渲染内容：一个窗口层(`VkSurfaceKHR`)和一个交换链(`VkSwapchainKHR`)。值得注意的是`KHR`后缀表明这些对象是Vulkan扩展的一部分。
Vulkan API本身完全是平台未知的。这就是为什么我们需要一个`WSI`(窗口系统接口)扩展来和窗口管理器交互。窗口层是对要渲染的窗口的的扩平台抽象。通常通过提供一个原生窗口句柄来实现它的初始化。例如Windows上的`HWND`。
幸运的是GLFW库提供了一个内置的方法来处理这些平台相关的实现。

交换链是一个渲染目标集合。它的基本功能是保证我们当前渲染的图像和屏幕上显示的图像不相同。这保证了只有完整的图像可以被显示出来。每当我们需要画一帧时我们需要询问交换链提供一个用于渲染的图像。一帧画完后图像被返还给交换链，在某个时刻它被显示在屏幕上。
渲染目标的数量以及在屏幕上显示画完的图像的条件由显示模式确定。通用的显示模式有双倍缓冲(`vsync`)和三倍缓冲。我们会在创建交换链章节部分深入讲解这些内容。

一些平台允许通过`VK_KHR_display`和`VK_KHR_display_swapchain`扩展来直接渲染到显示器上而不和任一窗口管理器交互。这允许你创建用于全屏显示的窗口层或者实现你自己的窗口管理器。

##### 第4步：图像视图和帧缓冲
   要在从交换链获取的图像上画图，我们需要将它包裹到`VkImageView`和`VkFramebuffer`里。
图像视图是当前图像指定部分的引用；帧缓冲是图像视图的颜色、深度、模板目标的引用。
由于在交换链里存在许多不同的图像，我们可以为每个图像预先创建一个图像视图和帧缓冲并在画图时选择合适的对象。

##### 第5步：渲染通道
   Vulkan中的渲染通道描述了渲染操作时使用的图像的类型、他们被如何使用以及他们被如何对待。
在我们初始化的渲染三角形应用中，我们会告诉Vulkan我们将使用一个单独的图像作为颜色目标并且我们它在画图操作时明确知道是一个固定的颜色。
渲染通道只是描述了图像的类型，`VkFramebuffer`实际上绑定了指定图像与这些插槽的关联关系。

##### 第6步：图形管道
   图形管道在Vulkan中是通过创建`VkPipeline`对象开始的。
它描述了图形卡的可配置状态。比如视口大小及深度的缓冲操作和`VkShaderModule`对象的可编程状态。
`VkShaderModule`对象通过着色器字节码创建。驱动程序还需要知道将使用管道里的哪个渲染对象。这些对象是我们通过引用渲染通道指定的。
Vulkan对比于其他已存在的API特性最大的不同就是几乎所有的可配置图形管道都需要预先设置。
这意味着如果你想切换到不同的着色器或者稍微更改下顶点布局,你需要整个重新创建一遍图形管道。
这也意味着你需要为你的渲染操作的需要的所有不同组合预先创建许多`VkPipeline`对象。
只有像视口大小、清除颜色这些基础配置项可以动态改变。所有的状态都必须显式描述出来，例如不存在默认的颜色混合状态。
好消息是由于做了很多提前编译工作而不是即时编译,这有助于为驱动寻找更多优化机会并且运行时性能更加可预测，因为类似切换不同图形管道这种重大状态变动被显示执行。

##### 第7步：命令池和命令缓存区
   早先提到过Vulkan中许多操作像画图操作等都需要提交给一个队列。这些操作在可以提交前首先需要记录到一个`VkCommandBuffer`里。
这些命令缓冲是由一个关联了指定队列簇的`VkCommandPoll`分配的。
要画一个三角形我们需要在命令缓冲里记录以下操作：
    * 开始渲染通道
    * 绑定图形管道
    * 画3个顶点
    * 结束渲染通道
由于帧缓冲里的图像取决于交换链给我们的指定图像，我们需要为所有可能的图像记录一个命令缓冲并在画图时选取合适的那个。
另外一种方式是每帧记录一个命令缓冲，但这种方案不是很高效。

##### 第8步：主循环