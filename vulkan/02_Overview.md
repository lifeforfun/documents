### Vulkan的起点
   与其他的图形API一样，Vulkan被设计为[GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit)跨平台抽象的。
大部分这些API的问题是由于设计它们时那个年代图像硬件被限制为指定的一些可配置的功能。程序员需要以标准格式提供顶点数据并且受GPU亮度、着色产业限制。

   随着显卡工艺日趋成熟，开始提供越来越多的可编程功能。这些新的功能需要以某种方式集成进已有的API中。这就导致抽象程度不高并且需要很多臆测工作去覆盖程序员对现代图像工艺的需求。
这就是为什么为了提升游戏性能而发布如此多的驱动了,有时甚至是以重要补丁的方式发布。由于这些驱动的复杂性，应用开发者需要处理供应商的不一致行为，比如接受不同的[着色器](https://en.wikipedia.org/wiki/Shader)语法
除了这些新特性，过去十年间也汇集了一批搭载强大图形处理器的移动设备。这些移动端GPU基于能耗和空间的需求采用的工艺也不尽相同。
比如其中一种技术叫[排列式成像](https://en.wikipedia.org/wiki/Tiled_rendering)。这项功能可以给予开发人员更多的控制权而从性能提升中受益。
另一个在这些API产生的年代就存在的问题是对多线程的支持，这最终成为了CPU的瓶颈。

   通过为现代图形工艺设计重新设计全新的API，Vulkan能够解决以上这些问题。
它能让开发人员更清楚地选择符合他们预期的API来减轻驱动负担，并且允许通过多线程并行创建和提交命令。
通过切换到标准字节码格式和单一的编译器，减少了编译着色器的不一致性。
最终，通过将图形和计算功能统一为单一的API，实现了现代图形卡处理能力的通用目标。

### 画一个三角形需要什么?
   接下来我们看看一个良好的Vulkan程序渲染一个三角形需要哪些步骤。这里引进的所有概念将会下接下来的章节里详细讲解。这里只是给你一个关于所有这些独立组件的大致的印象。

#### 第1步：实例和物理设备的选择
   一个Vulkan应用通过`VkInstance`设置Vulkan API开始。一个实例创建时携带了描述应用和任何你用到的API扩展信息。创建实例后，你可以查询Vulkan支持的硬件，选择使用一个或多个`VkPhysicalDevice`来进行操作。
你可以查找类似`VRAM`大小这样的属性或设备能力来确定选择哪些设备。例如你会更倾向于使用专业的图形卡。

#### 第2步：逻辑设备和队列簇
   在选择使用合适的硬件之后你需要创建一个`VkDevice`(逻辑设备)。它可以更详细地描述你要使用的类似于视窗渲染和64位浮点这些`VkPhysicalDeviceFeatures`(物理设备属性)。
同样你还需要指定使用哪种队列簇。用Vulkan执行的大部分操作比如画图命令和内存操作都是通过提交给`VkQueue`异步执行的。这些队列是通过队列簇分配。每种队列簇支持他的队列的一些指定操作集。
例如，针对图形、计算、内存传输操作可能分别有对应的队列簇来处理。不同队列簇的可用性可以作为选择物理设备的评判条件。可能一个Vulkan支持的设备不提供任何图形方面的功能。但现今所有Vulkan支持的图形卡通常都支持所有我们感兴趣的队列操作。

#### 第3步：窗口表层和交换链
   除非你对幕后渲染感兴趣，否则你需要创建一个窗口去显示渲染的图像。窗口可以通过类似[GLFW](http://www.glfw.org/)和[SDL](https://www.libsdl.org/)这些平台原生API或库创建。在这个教程里我们使用GLFW,下个章节会介绍更多这方面的内容。
   
我们还需要两个组件来向窗口里渲染内容：一个窗口层(`VkSurfaceKHR`)和一个交换链(`VkSwapchainKHR`)。值得注意的是`KHR`后缀表明这些对象是Vulkan扩展的一部分。
Vulkan API本身完全是平台未知的。这就是为什么我们需要一个`WSI`(窗口系统接口)扩展来和窗口管理器交互。窗口层是对要渲染的窗口的的扩平台抽象。通常通过提供一个原生窗口句柄来实现它的初始化。例如Windows上的`HWND`。
幸运的是GLFW库提供了一个内置的函数来处理这些平台相关的实现。

交换链是一个渲染目标集合。它的基本功能是保证我们当前渲染的图像和屏幕上显示的图像不相同。这保证了只有完整的图像可以被显示出来。每当我们需要画一帧时我们需要询问交换链提供一个用于渲染的图像。一帧画完后图像被返还给交换链，在某个时刻它被显示在屏幕上。
渲染目标的数量以及在屏幕上显示画完的图像的条件由显示模式确定。通用的显示模式有双倍缓冲(`vsync`)和三倍缓冲。我们会在创建交换链章节部分深入讲解这些内容。

一些平台允许通过`VK_KHR_display`和`VK_KHR_display_swapchain`扩展来直接渲染到显示器上而不和任一窗口管理器交互。这允许你创建用于全屏显示的窗口层或者实现你自己的窗口管理器。

#### 第4步：图像视图和帧缓冲
   要在从交换链获取的图像上画图，我们需要将它包裹到`VkImageView`和`VkFramebuffer`里。
图像视图是当前图像指定部分的引用；帧缓冲是图像视图的颜色、深度、模板目标的引用。
由于在交换链里存在许多不同的图像，我们可以为每个图像预先创建一个图像视图和帧缓冲并在画图时选择合适的对象。

#### 第5步：渲染通道
   Vulkan中的渲染通道描述了渲染操作时使用的图像的类型、他们被如何使用以及他们被如何对待。
在我们初始化的渲染三角形应用中，我们会告诉Vulkan我们将使用一个单独的图像作为颜色目标并且我们它在画图操作时明确知道是一个固定的颜色。
渲染通道只是描述了图像的类型，`VkFramebuffer`实际上绑定了指定图像与这些插槽的关联关系。

#### 第6步：图形管道
   图形管道在Vulkan中是通过创建`VkPipeline`对象开始的。
它描述了图形卡的可配置状态。比如视口大小及深度的缓冲操作和`VkShaderModule`对象的可编程状态。
`VkShaderModule`对象通过着色器字节码创建。驱动程序还需要知道将使用管道里的哪个渲染对象。这些对象是我们通过引用渲染通道指定的。
Vulkan对比于其他已存在的API特性最大的不同就是几乎所有的可配置图形管道都需要预先设置。
这意味着如果你想切换到不同的着色器或者稍微更改下顶点布局,你需要整个重新创建一遍图形管道。
这也意味着你需要为你的渲染操作的需要的所有不同组合预先创建许多`VkPipeline`对象。
只有像视口大小、清除颜色这些基础配置项可以动态改变。所有的状态都必须显式描述出来，例如不存在默认的颜色混合状态。
好消息是由于做了很多提前编译工作而不是即时编译,这有助于为驱动寻找更多优化机会并且运行时性能更加可预测，因为类似切换不同图形管道这种重大状态变动被显式执行。

#### 第7步：命令池和命令缓存区
   早先提到过Vulkan中许多操作像画图操作等都需要提交给一个队列。这些操作在可以提交前首先需要记录到一个`VkCommandBuffer`里。
这些命令缓冲是由一个关联了指定队列簇的`VkCommandPoll`分配的。
要画一个三角形我们需要在命令缓冲里记录以下操作：
    * 开始渲染通道
    * 绑定图形管道
    * 画3个顶点
    * 结束渲染通道
由于帧缓冲里的图像取决于交换链给我们的指定图像，我们需要为所有可能的图像记录一个命令缓冲并在画图时选取合适的那个。
另外一种方式是每帧记录一个命令缓冲，但这种方案不是很高效。

#### 第8步：主循环
   现在这些画图命令被包裹进了一个命令缓冲，主循环看起来见文知义。
我们通过`vkAcquireNextImageKHR`由交换链获取一张图像。接下来我们就可以选择适合这张图的命令缓冲通过`vkQueueSubmit`执行。
最后我们使用`vkQueuePresentKHR`返还图像给交换链来显示到屏幕上。
提交给队列的操作是异步执行的。
因此我们需要使用到一些同步对象比如信号量来保证执行顺序。
画图缓冲必须设置为等待图像获取完成以后才执行，否则可能出现渲染一张还在被读取并显示到屏幕的图像。
`vkQueuePresentKHR`的调用反过来需要等待渲染操作完成，我们需要使用渲染完成时发出的第二个信号量。

#### 总结
   这个略显简陋的入门教程应该可以让你大概理解画一个三角形之前的工作了。
一个真实世界的程序包含了更多的步骤，比如分配顶点缓冲、创建统一缓冲以及上传纹理图像，这些将会在后续章节讲到。
但是我们开始时尽量简单，因为Vulkan有足够陡峭的学习曲线。
值得说明的是我们会在顶点着色器里初始嵌入顶点坐标而不是使用顶点缓冲，因为管理顶点缓冲首先需要熟悉一些命令缓冲相关知识。

简短来说，画出我们第一个三角形需要：
    * 创建`VkInstance`
    * 选择支持的图形卡(`VkPhysicalDevice`)
    * 为画图和显示创建一个`VkDevice`和`VkQueue`
    * 创建一个窗口、窗口层和交换链
    * 把交换链图像包裹进`VkImageView`
    * 创建渲染通道并指定渲染对象和用法
    * 为渲染通道创建若干帧缓冲
    * 设置图形管道
    * 为每个可能的交换链图像分配命令缓冲并录入画图命令
    * 通过获取图像、提交正确的画图命令缓冲然后返还图像给交换链来画帧
看似步骤很多，目的是让接下来的每个章节都尽量做到每个独立的步骤简单和清晰明了。
如果你对整个程序的其中一个步骤感到疑惑，那你应该回过头再看下那一章节。

#### API概念
   这一节我们简要了解一下Vulkan API在底层是什么结构。

##### 编码约定
   所有的Vulkan函数、枚举和结构体都定义在`vulkan.h`头文件里。这个头文件包含在LunarG开发的[Vulkan SDK](https://www.lunarg.com/vulkan-sdk/)中。
我们会在下一章学习安装Vulkan SDK。

函数以小写`vk`前缀开头,枚举、结构体等类型以`Vk`作为前缀，枚举值以`VK_`前缀。
API重度使用结构体作为函数参数。比如，创建对象通常使用如下格式：
```cpp
VkXXXCreateInfo createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```
Vulkan中的许多结构需要通过`sType`字段指定结构类型。
`pNext`字段可以指向一个扩展结构，这个教程里它将总是`nullptr`。
创建和销毁对象的函数有一个`VkAllocationCallbacks`参数用于让你使用一个自定义的内存驱动器，这个教程里也总是`nullptr`。

几乎所有返回`VkResult`的函数要么返回`VK_SUCCESS`要么返回一个错误码。标准里描述了每个函数返回哪些错误码以及它们的意义。

##### 验证层
   前面已经提及过Vulkan被设计为高性能、低驱动负载的，因此它默认只包含很有限的错误检查和调试能力。
如果你做了某些错误操作驱动器经常会崩溃而不是返回一个错误码。
甚至更糟糕的情况是在你的图形卡上看起来运行良好而在其他图形卡上完全不能运行。

Vulkan通过提供一个熟知的验证层特性来允许你执行许多检测。
验证层是一段可以插入到API和图形驱动中间的代码。它可以执行类似额外的函数参数检测、跟踪内存管理问题等操作。
它的好处是你可以在开发时启用它而在发布时完全关闭它从而实现了零开销。
任何人都可以编写他们自己的验证层，但LunarG的Vulkan SDK提供了一组标准验证层，我们会在教程中使用它们。
同样你需要注册一个回调函数来从这些验证层里接收调试信息。

由于Vulkan显式执行所有操作并且验证层拥有良好的扩展性，它会比OpenGL和Direct3D更容易找出你的黑屏原因。

距离我们开始编写代码仅剩一步了，那就是[配置开发环境](03_Development_environment.md)。